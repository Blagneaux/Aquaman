import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF

# Build toy data in 3D space
x1 = np.linspace(start=0, stop=10, num=20)
x2 = np.linspace(start=0, stop=10, num=20)
X1, X2 = np.meshgrid(x1, x2)
X = np.column_stack([X1.ravel(), X2.ravel()])
y = np.squeeze(X[:, 0] * np.sin(X[:, 1]))

# ------------------------------------------------------------
# Read the observation file generated by Liypad
# ------------------------------------------------------------

# Initialize std_prediction for the first loop
std_prediction = None

# Random state
rng = np.random.RandomState(1)

while True:
    # Select experimental measurements from toy data
    if std_prediction is not None:
        new_index = np.argmax(std_prediction)
        if new_index not in training_indices:
            training_indices = np.append(training_indices, new_index)
            # ------------------------------------------------------------
            # Write a file with the coordinates of the next observation, to use it as input for Lilypad
            # ------------------------------------------------------------
    else:
        training_indices = rng.choice(np.arange(y.size), size=10, replace=False)

    X_train, y_train = X[training_indices], y[training_indices]

    # Add some noise
    noise_std = 0.75
    y_train_noisy = y_train + rng.normal(loc=0.0, scale=noise_std, size=y_train.shape)

    # Create the Gaussian process model
    kernel = 1 * RBF(length_scale=1.0, length_scale_bounds=(1e-2, 1e2))
    gaussian_process = GaussianProcessRegressor(
        kernel=kernel, alpha=noise_std ** 2, n_restarts_optimizer=9
    )
    gaussian_process.fit(X_train, y_train_noisy)
    mean_prediction, std_prediction = gaussian_process.predict(X, return_std=True)

    # Plot the result in 3D
    fig = plt.figure()
    ax = fig.add_subplot(211, projection='3d')
    ax.scatter(X_train[:, 0], X_train[:, 1], y_train_noisy, color='blue', label='Observations')
    ax.plot_trisurf(X[:, 0], X[:, 1], mean_prediction, linewidth=0.2, antialiased=True, cmap='viridis', alpha=0.5, label='Mean prediction')
    ax.plot_surface(X1, X2, y.reshape(X1.shape), color='tab:orange', alpha=0.3, label='Real surface')  # Adding real surface
    ax.set_xlabel('X1')
    ax.set_ylabel('X2')
    ax.set_zlabel('f(X1, X2)')
    plt.legend()
    ax2 = fig.add_subplot(212, projection='3d')
    ax2.plot_trisurf(X[:, 0], X[:, 1], np.abs(mean_prediction-y), linewidth=0.2, antialiased=True, cmap='viridis', alpha=0.5, label='Difference')
    plt.suptitle("Gaussian process regression on a noisy dataset")
    plt.legend()
    plt.show()

    # Ask if the user wants to continue
    cont = input("Do you want to continue? (y/n): ")
    if cont.lower() != 'y':
        break
